<!doctype html>

<meta charset="utf-8">

<style>
    body {
        font-family: sans-serif;
        font-weight: 100;
        padding: 2em;
    }
    input {
        border: 1px solid #ccc;
        margin: 0;
    }
    input:focus {
        border-color: #444;
    }
</style>
<link rel="stylesheet" href="pick.css">
<style>
    .tooltip {
        font-size: 12px;
        position: absolute;
        max-height: 0;
        overflow: hidden;
    }
    .tooltip--opened {
        max-height: 10em;
    }
        .tooltip__holder {
            background: #333;
            color: #fff;
            padding: 8px 10px;
        }
</style>
<style>
    .picker__frame {
        padding: 1em;
    }
    .picker__list {
        margin: 0;
    }
    .div:after {
        content: ' value: ' attr(data-value);
        font-weight: bold;
        font-size: .8em;
        color: #0089ec;
    }
</style>
<style>
    .colorpicker__input--active {
        border-color: #0089ec !important;
    }
    .colorpicker {
        font-size: 16px;
        text-align: left;
        line-height: 1.2;
        color: #000000;
        position: absolute;
        z-index: 10000;
    }
    .colorpicker--opened {
        max-height: 10em;
    }
    .colorpicker__holder {
        width: 100%;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        position: absolute;
        background: #ffffff;
        border: 1px solid #aaaaaa;
        width: 150px;
        border-radius: 5px;
        max-height: 0;
        opacity: 0;
        -webkit-transform: translateY(-1em) perspective(600px) rotateX(10deg);
        -webkit-transition: all 0.15s ease-out, max-height 0 0.15s;
    }
    .colorpicker--opened .colorpicker__holder {
        max-height: 25em;
        opacity: 1;
        -webkit-transform: translateY(0) perspective(600px) rotateX(0);
        -webkit-transition: all 0.15s ease-out, max-height 0;
        box-shadow: 0 6px 18px 1px rgba(0, 0, 0, 0.12);
    }
    .colorpicker__box {
        padding: .5em;
    }
    .colorpicker__list {
        list-style: none;
        padding: 0;
        margin: 0;
        font-size: 0.1px; /* To remove the gaps between lists */
    }
    .colorpicker__list-item {
        display: inline-block;
        width: 20px;
        padding-top: 20px;
        position: relative;
        margin-right: 2px;
        margin-bottom: 2px;
    }
    .colorpicker__color {
        cursor: pointer;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 2px solid transparent;
    }
</style>

<a class="anchor" href="#" title="some title">some link</a>

<br><br>
<div class="div" data-value="1">hello there</div>

<br><br>
<input class="color" type="color">

<br><br>
<input class="input" type="date">

<script src="jquery.js"></script>
<script src="pick.js"></script>
<script>
    Pick.extend({
        name: 'tooltip',

        // Need `prefix` to namespace the classes with a prefix.
        prefix: 'tooltip',

        // Need `alias` to shorthand the picker jquery link.
        alias: 'tooltip',

        content: function() {
            var $node = this.$node,
                title = $node.attr( 'title' )
            $node.removeAttr( 'title' )
            return title
        },

        // Need `defaults` as default settings.
        defaults: {
            klass: {
                input: 'element',
                something: 'someclassname'
            }
        },
        onStart: function() {
            var picker = this
            picker.$node.on({
                hover: picker.open,
                mouseout: picker.close,
                click: picker.close
            })
        }
    })
    $( '.anchor' ).tooltip()
</script>
<script>
    Pick.extend({

        name: 'dropdown',

        alias: 'drop_it_like_its_hot',

        // Need `content` to set content to insert.
        content: function() {
            var picker = this,
                collection = picker.get( 'collection' ),
                selected = picker.get( 'select' ),
                highlighted = picker.get( 'highlight' )
            return Pick._.node(
                'ul',
                Pick._.range({
                    min: 0,
                    max: collection.length - 1,
                    item: function( count ) {
                        var attributes = 'style="' +
                            ( count === selected ? 'color:red' : '' ) +
                            ( count === highlighted ? ';background:lightblue' : '' ) +
                            '"'
                        return Pick._.node(
                            'li',
                            collection[ count ],
                            'list-item',
                            'data-pick="' + count + '"' + attributes
                        )
                    }
                }),
                'list'
            )
        },

        keys: {
            13: 'select',
            38: -1,
            40: 1,
            go: function( movement ) {
                var picker = this,
                    highlighted = picker.get( 'highlight' )
                if ( Pick._.isInteger( movement ) ) {
                    picker.set( 'highlight', highlighted + movement )
                }
                else {
                    picker.set( 'select', highlighted ).close()
                }
            }
        },

        // Need `dict` to have a dictionary of default things.
        dict: {

            // Default diction values.
            values: {

                // Collection of things.
                collection: [ 'heading 01', 'heading 02', 'heading 03', 'body' ],

                // Selected item.
                select: 0,

                // Highlighted item.
                highlight: 0
            },

            // Get or set things with formatting, etc.
            get: function( type, options ) {
                return this.extension.dict.values[ type ]
            },
            set: function( type, value, options ) {

                var picker = this

                // Continue through any cascading changes.
                if ( type == 'select' ) picker.set( 'highlight', value )

                return picker.extension.dict.values[ type ] = value
            }
        },

        // When things are initialized. nothing is ready yet.
        init: function() {
            var picker = this,
                defaultValue = picker.$node.data( 'value' )
            if ( defaultValue ) {
                picker.extension.dict.values.select = defaultValue
            }
        },

        onStart: function() {
            var picker = this
            picker.$node.on( 'click', function() {
                picker.open( true )
            })
        }
    })
    // $( '.div' ).pick( 'dropdown' )
    $( '.div' ).drop_it_like_its_hot()
    // var picker = $( '.div' ).pick( 'dropdown', 'picker' ).open()
</script>
<script>
    Pick.extend({
        name: 'colorpicker',
        alias: 'colorpicker',
        prefix: 'colorpicker',

        defaults: {
            klass: {
                list: 'list',
                listItem: 'list-item',
                color: 'color'
            }
        },

        dict: {
            values: {
                colors: [ 'red', 'green', 'black', 'purple', '#0089ec', '#ff0', 'orange', 'brown', 'grey' ],
                select: 'purple'
            },
            get: function( type, options ) {
                return this.extension.dict.values[ type ]
            },
            set: function( type, value, options ) {
                return this.extension.dict.values[ type ] = value
            }
        },

        content: function() {

            var picker = this,
                colors = picker.get( 'colors' ),
                selectedColor = picker.get( 'select' ),
                classes = picker.klass

            return Pick._.node(
                'ul',
                Pick._.range({
                    min: 0,
                    max: colors.length - 1,
                    item: function( count ) {
                        var colorvalue = colors[ count ]
                        return Pick._.node(
                            'li',
                            Pick._.node(
                                'div',
                                '', classes.color,
                                'data-pick="' + colorvalue + '" style="background:' + colorvalue + ( colorvalue === selectedColor ? ';box-shadow:inset 0 0 0 1px #fff;border-color:black' : '' ) + '"'
                            ),
                            classes.listItem
                        )
                    }
                }),
                classes.list
            ) + '<p><input tabindex=-1 type=text value=' + selectedColor + '></p>'
        }, //content

        onStart: function() {
            var picker = this,
                $input = picker.$root.find( 'input' )
            picker.$root.on( 'keyup', function() {
                picker.$node.val( $input.val() )
            })
        }
    })
    $( '.color' ).colorpicker()
    $( '.color' ).colorpicker( 'open', true )
</script>
<!--<script>
    Pick.extend({
        name: 'colorpicker',
        content: function() {
            var picker = this,
                extension = picker.extension,
                colors = extension.dict.colors(),
                linkcolor = extension.dict.linkcolor(),
                numInRow = 4

            return Pick._.node(
                'table',
                Pick._.range({
                    min: 0,
                    max: colors.length / numInRow - 1,
                    item: function( row ) {
                        return Pick._.node(
                            'tr',
                            Pick._.range({
                                min: row * numInRow,
                                max: function() {
                                    return this.min + numInRow - 1
                                },
                                item: function( count ) {
                                    var colorvalue = colors[ count ]
                                    return Pick._.node( 'td', Pick._.node(
                                        'div',
                                        'color', '',
                                        'data-pick="' + colorvalue + '"' + ( colorvalue === linkcolor ? 'style="color:' + linkcolor + '"' : '' )
                                    ))
                                }
                            })
                        )
                    }
                }),
                picker.settings.klass.table
            )
        },
        dict: (function() {

            var linkvalue = localStorage.color || '#0089ec'

            return {
                colors: function() {
                    return [ 'red', 'green', 'black', '#0089ec', '#ff0', 'orange', 'brown', 'grey' ]
                },
                linkcolor: function( value ) {
                    if ( value ) linkvalue = localStorage.color = value
                    return linkvalue
                }
            }
        })(),

        // Need `define` to add things to the dictionary.
        define: function( thing, value, options ) {
            return Pick._.trigger( this.dict[ thing ], this.dict, [ value, options ] )
        },
        onStart: function() {
            var picker = this,
                extension = this.extension
            picker.$root.on( 'click', '[data-pick]', function( event ) {
                extension.define( 'linkcolor', $( this ).data( 'pick' ) )
                picker.render()
            })
        },

        defaults: {
            klass: {
                table: 'picker__table'
            }
        }
    })
    $( '.color' ).pick( 'colorpicker' ).pick( 'colorpicker', 'open' )
</script>
<script>


    /**
     * Globals and constants
     */
    var DAYS_IN_WEEK = 7,
        WEEKS_IN_CALENDAR = 6

    function pickadateInit( picker ) {

        var calendar = this,

            settings = picker.settings,

            elementDataValue = picker.$node.data( 'value' ),

            // The queue of methods that will be used to build item objects.
            queues = {
                min: 'measure create',
                max: 'measure create',
                now: 'now create',
                select: 'parse create validate',
                highlight: 'navigate create validate',
                view: 'create validate viewset',
                disable: 'flipItem',
                enable: 'flipItem'
            },

            // Items maker.
            maker = {


                /**
                 * Set a datepicker item object.
                 */
                set: function( type, value, options ) {

                    // Map through and invoke each item’s queue of methods – always updating the value.
                    // * In the case of `enable`, keep the queue but set `disable` instead.
                    //   And in the case of `flip`, keep the queue but set `enable` instead.
                    items[ type ] = queues[ type ].split( ' ' ).map( function( method ) {
                        return value = maker[ method ]( type, value, options )
                    }).pop()

                    // Check if we need to cascade through more updates.
                    if ( type == 'select' ) {
                        maker.set( 'highlight', items.select, options )
                    }
                    else if ( type == 'highlight' ) {
                        maker.set( 'view', items.highlight, options )
                    }
                    else if ( ( type == 'flip' || type == 'min' || type == 'max' || type == 'disable' || type == 'enable' ) && items.select && items.highlight ) {
                        maker.
                            set( 'select', items.select, options ).
                            set( 'highlight', items.highlight, options )
                    }

                    return this
                }, //set


                /**
                 * Create a picker date object.
                 */
                create: function( type, value, options ) {

                    var isInfiniteValue

                    // If there’s no value, use the type as the value.
                    value = value === undefined ? type : value


                    // If it’s infinity, update the value.
                    if ( value == -Infinity || value == Infinity ) {
                        isInfiniteValue = value
                    }

                    // If it’s an object, use the native date object.
                    else if ( Pick._.isObject( value ) && Pick._.isInteger( value.pick ) ) {
                        value = value.obj
                    }

                    // If it’s an array, convert it into a date.
                    else if ( Array.isArray( value ) ) {
                        value = new Date( value[ 0 ], value[ 1 ], value[ 2 ] )
                    }

                    // If it’s a number or date object, make a normalized date.
                    else if ( Pick._.isInteger( value ) || Pick._.isDate( value ) ) {
                        value = maker.normalize( new Date( value ), options )
                    }

                    // If it’s a literal true or any other case, set it to now.
                    else /*if ( value === true )*/ {
                        value = maker.now( type, value, options )
                    }

                    // Return the compiled object.
                    return {
                        year: isInfiniteValue || value.getFullYear(),
                        month: isInfiniteValue || value.getMonth(),
                        date: isInfiniteValue || value.getDate(),
                        day: isInfiniteValue || value.getDay(),
                        obj: isInfiniteValue || value,
                        pick: isInfiniteValue || value.getTime()
                    }
                }, //create


                /**
                 * Measure the range of dates.
                 */
                measure: function( type, value/*, options*/ ) {

                    var maker = this

                    // If it's anything false-y, remove the limits.
                    if ( !value ) {
                        value = type == 'min' ? -Infinity : Infinity
                    }

                    // If it's an integer, get a date relative to today.
                    else if ( Pick._.isInteger( value ) ) {
                        value = maker.now( type, value, { rel: value } )
                    }

                    return value
                }, //measure


                /**
                 * Get the date today.
                 */
                now: function( type, value, options ) {
                    value = new Date()
                    if ( options && options.rel ) {
                        value.setDate( value.getDate() + options.rel )
                    }
                    return this.normalize( value, options )
                }, //now


                /**
                 * Navigate to next/prev month.
                 */
                navigate: function( type, value, options ) {

                    if ( Pick._.isObject( value ) ) {

                        var targetDateObject = new Date( value.year, value.month + ( options && options.nav ? options.nav : 0 ), 1 ),
                            year = targetDateObject.getFullYear(),
                            month = targetDateObject.getMonth(),
                            date = value.date

                        // If the month we’re going to doesn’t have enough days,
                        // keep decreasing the date until we reach the month’s last date.
                        while ( new Date( year, month, date ).getMonth() !== month ) {
                            date -= 1
                        }

                        value = [ year, month, date ]
                    }

                    return value
                }, //navigate


                /**
                 * Normalize a date by setting the hours to midnight.
                 */
                normalize: function( value/*, options*/ ) {
                    value.setHours( 0, 0, 0, 0 )
                    return value
                },


                /**
                 * Validate a date as enabled and shift if needed.
                 */
                validate: function( type, dateObject, options ) {

                    var
                        // Keep a reference to the original date.
                        originalDateObject = dateObject,

                        // Make sure we have an interval.
                        interval = options && options.interval ? options.interval : 1,

                        // Check if the calendar enabled dates are inverted.
                        isInverted = items.enable === -1,

                        // Check if we have any enabled dates after/before now.
                        hasEnabledBeforeTarget, hasEnabledAfterTarget,

                        // The min & max limits.
                        minLimitObject = items.min,
                        maxLimitObject = items.max,

                        // Check if we’ve reached the limit during shifting.
                        reachedMin, reachedMax,

                        // Check if the calendar is inverted and at least one weekday is enabled.
                        hasEnabledWeekdays = isInverted && items.disable.filter( function( value ) {

                            // If there’s a date, check where it is relative to the target.
                            if ( Array.isArray( value ) ) {
                                var dateTime = maker.create( value ).pick
                                if ( dateTime < dateObject.pick ) hasEnabledBeforeTarget = true
                                else if ( dateTime > dateObject.pick ) hasEnabledAfterTarget = true
                            }

                            // Return only integers for enabled weekdays.
                            return Pick._.isInteger( value )
                        }).length



                    // Cases to validate for:
                    // [1] Not inverted and date disabled.
                    // [2] Inverted and some dates enabled.
                    // [3] Out of range.
                    //
                    // Cases to **not** validate for:
                    // • Not inverted and date enabled.
                    // • Inverted and all dates disabled.
                    // • Navigating months.
                    // • ..and anything else.
                    if (
                        /* 1 */ ( !isInverted && maker.disabled( dateObject ) ) ||
                        /* 2 */ ( isInverted && maker.disabled( dateObject ) && ( hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget ) ) ||
                        /* 3 */ ( dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick )
                    ) {


                        // When inverted, flip the direction if there aren’t any enabled weekdays
                        // and there are no enabled dates in the direction of the interval.
                        if ( isInverted && !hasEnabledWeekdays && ( ( !hasEnabledAfterTarget && interval > 0 ) || ( !hasEnabledBeforeTarget && interval < 0 ) ) ) {
                            interval *= -1
                        }


                        // Keep looping until we reach an enabled date.
                        while ( maker.disabled( dateObject ) ) {


                            // If we’ve looped into the next/prev month, return to the original date and flatten the interval.
                            if ( Math.abs( interval ) > 1 && ( dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month ) ) {
                                dateObject = originalDateObject
                                interval = Math.abs( interval ) / interval
                            }


                            // If we’ve reached the min/max limit, reverse the direction and flatten the interval.
                            if ( dateObject.pick <= minLimitObject.pick ) {
                                reachedMin = true
                                interval = 1
                            }
                            else if ( dateObject.pick >= maxLimitObject.pick ) {
                                reachedMax = true
                                interval = -1
                            }


                            // If we’ve reached both limits, just break out of the loop.
                            if ( reachedMin && reachedMax ) {
                                break
                            }


                            // Finally, create the shifted date using the interval and keep looping.
                            dateObject = maker.create([ dateObject.year, dateObject.month, dateObject.date + interval ])
                        }

                    } //endif


                    // Return the date object settled on.
                    return dateObject
                }, //validate


                /**
                 * Create a viewset object based on navigation.
                 */
                viewset: function( type, dateObject/*, options*/ ) {
                    return this.create([ dateObject.year, dateObject.month, 1 ])
                },


                /**
                 * Check if an object is disabled.
                 */
                disabled: function( dateObject ) {

                    var
                        // Filter through the disabled dates to check if this is one.
                        isDisabledDate = items.disable.filter( function( dateToDisable ) {

                            // If the date is a number, match the weekday with 0index and `firstDay` check.
                            if ( Pick._.isInteger( dateToDisable ) ) {
                                return dateObject.day === ( settings.firstDay ? dateToDisable : dateToDisable - 1 ) % 7
                            }

                            // If it's an array, create the object and match the exact date.
                            if ( Array.isArray( dateToDisable ) ) {
                                return dateObject.pick === maker.create( dateToDisable ).pick
                            }
                        }).length


                    // It’s disabled beyond the min/max limits. If within the limits, check the
                    // calendar “enabled” flag is flipped and respectively flip the condition.
                    return dateObject.pick < items.min.pick ||
                        dateObject.pick > items.max.pick ||
                        items.enable === -1 ? !isDisabledDate : isDisabledDate
                }, //disabled


                /**
                 * Parse a string into a usable type.
                 */
                parse: function( type, value, options ) {

                    var parsingObject = {}

                    if ( !value || Pick._.isInteger( value ) || Array.isArray( value ) || Pick._.isDate( value ) || Pick._.isObject( value ) && Pick._.isInteger( value.pick ) ) {
                        return value
                    }

                    // We need a `.format` to parse the value.
                    if ( !( options && options.format ) ) {
                        // should probably default to the default format.
                        throw "Need a formatting option to parse this.."
                    }

                    // Convert the format into an array and then map through it.
                    maker.formats.toArray( options.format ).map( function( label ) {

                        var
                            // Grab the formatting label.
                            formattingLabel = maker.formats[ label ],

                            // The format length is from the formatting label function or the
                            // label length without the escaping exclamation (!) mark.
                            formatLength = formattingLabel ? Pick._.trigger( formattingLabel, maker, [ value, parsingObject ] ) : label.replace( /^!/, '' ).length

                        // If there's a format label, split the value up to the format length.
                        // Then add it to the parsing object with appropriate label.
                        if ( formattingLabel ) {
                            parsingObject[ label ] = value.substr( 0, formatLength )
                        }

                        // Update the value as the substring from format length to end.
                        value = value.substr( formatLength )
                    })

                    // If it’s parsing a `data-value`, compensate for month 0index.
                    return [ parsingObject.yyyy || parsingObject.yy, +( parsingObject.mm || parsingObject.m ) - ( options.data ?  1 : 0 ), parsingObject.dd || parsingObject.d ]
                } //parse

            }, //maker

            // The component's item object.
            items = {}

        items.disable = ( settings.disable || [] ).slice( 0 )
        items.enable = -(function( collectionDisabled ) {
            return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1
        })( items.disable )

        maker.
            set( 'min', settings.min ).
            set( 'max', settings.max ).
            set( 'now' ).

            // Setting the `select` also sets the `highlight` and `view`.
            set( 'select',

                // If there's a `value` or `data-value`, use that with formatting.
                // Otherwise default to selecting “today”.
                elementDataValue || picker.$node[ 0 ].value || items.now,

                // Use the relevant format and data property.
                { format: elementDataValue ? settings.formatSubmit : settings.format, data: !!elementDataValue }
            )


        calendar.dict = function( type, options ) {
            return items[ type ]
        }

    } //pickadateInit

    Pick.extend({
        name: 'pickadate',
        init: pickadateInit,
        content: function() {

            var calendar = this,
                settings = calendar.settings,
                nowObject = calendar.get( 'now' )
                selectedObject = calendar.get( 'select' ),
                highlightedObject = calendar.get( 'highlight' ),
                viewsetObject = calendar.get( 'view' ),
                disabledCollection = calendar.get( 'disable' ),
                minLimitObject = calendar.get( 'min' ),
                maxLimitObject = calendar.get( 'max' ),


                // Create the calendar table head using a copy of weekday labels collection.
                // * We do a copy so we don't mutate the original array.
                tableHead = (function( collection ) {

                    // If the first day should be Monday, move Sunday to the end.
                    if ( settings.firstDay ) {
                        collection.push( collection.shift() )
                    }

                    // Create and return the table head group.
                    return Pick._.node(
                        'thead',
                        Pick._.range({
                            min: 0,
                            max: DAYS_IN_WEEK - 1,
                            i: 1,
                            item: function( counter ) {
                                return Pick._.node( 'th', collection[ counter ], settings.klass.weekdays )
                            }
                        })
                    ) //endreturn
                })( ( settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysShort ).slice( 0 ) ), //tableHead


                // Create the nav for next/prev month.
                createMonthNav = function( next ) {

                    // Otherwise, return the created month tag.
                    return Pick._.node(
                        'div',
                        ' ',
                        settings.klass[ 'nav' + ( next ? 'Next' : 'Prev' ) ] + (

                            // If the focused month is outside the range, disabled the button.
                            ( next && viewsetObject.year >= maxLimitObject.year && viewsetObject.month >= maxLimitObject.month ) ||
                            ( !next && viewsetObject.year <= minLimitObject.year && viewsetObject.month <= minLimitObject.month ) ?
                            ' ' + settings.klass.navDisabled : ''
                        ),
                        'data-nav=' + ( next || -1 )
                    ) //endreturn
                }, //createMonthNav


                // Create the month label.
                createMonthLabel = function( monthsCollection ) {

                    // If there are months to select, add a dropdown menu.
                    if ( settings.selectMonths ) {

                        return Pick._.node( 'select', Pick._.range({
                            min: 0,
                            max: 11,
                            item: function( loopedMonth ) {

                                return Pick._.node( 'option',

                                    // The looped month and no classes.
                                    monthsCollection[ loopedMonth ], 0,

                                    // Set the value and selected index.
                                    'value=' + loopedMonth +
                                    ( viewsetObject.month == loopedMonth ? ' selected' : '' ) +
                                    (
                                        (
                                            ( viewsetObject.year == minLimitObject.year && loopedMonth < minLimitObject.month ) ||
                                            ( viewsetObject.year == maxLimitObject.year && loopedMonth > maxLimitObject.month )
                                        ) ?
                                        ' disabled' : ''
                                    )
                                )
                            }
                        }), settings.klass.selectMonth, isOpen ? '' : 'disabled' )
                    }

                    // If there's a need for a month selector
                    return Pick._.node( 'div', monthsCollection[ viewsetObject.month ], settings.klass.month )
                }, //createMonthLabel


                // Create the year label.
                createYearLabel = function() {

                    var focusedYear = viewsetObject.year,

                    // If years selector is set to a literal "true", set it to 5. Otherwise
                    // divide in half to get half before and half after focused year.
                    numberYears = settings.selectYears === true ? 5 : ~~( settings.selectYears / 2 )

                    // If there are years to select, add a dropdown menu.
                    if ( numberYears ) {

                        var
                            minYear = minLimitObject.year,
                            maxYear = maxLimitObject.year,
                            lowestYear = focusedYear - numberYears,
                            highestYear = focusedYear + numberYears

                        // If the min year is greater than the lowest year, increase the highest year
                        // by the difference and set the lowest year to the min year.
                        if ( minYear > lowestYear ) {
                            highestYear += minYear - lowestYear
                            lowestYear = minYear
                        }

                        // If the max year is less than the highest year, decrease the lowest year
                        // by the lower of the two: available and needed years. Then set the
                        // highest year to the max year.
                        if ( maxYear < highestYear ) {

                            var availableYears = lowestYear - minYear,
                                neededYears = highestYear - maxYear

                            lowestYear -= availableYears > neededYears ? neededYears : availableYears
                            highestYear = maxYear
                        }

                        return Pick._.node( 'select', Pick._.range({
                            min: lowestYear,
                            max: highestYear,
                            item: function( loopedYear ) {
                                return Pick._.node( 'option',

                                    // The looped year and no classes.
                                    loopedYear, 0,

                                    // Set the value and selected index.
                                    'value=' + loopedYear + ( focusedYear == loopedYear ? ' selected' : '' )
                                )
                            }
                        }), settings.klass.selectYear, isOpen ? '' : 'disabled' )
                    }

                    // Otherwise just return the year focused
                    return Pick._.node( 'div', focusedYear, settings.klass.year )
                } //createYearLabel

                console.log( 'i was here' )

            // Create and return the entire calendar.
            return Pick._.node(
                'div',
                createMonthNav() + createMonthNav( 1 ) +
                createMonthLabel( settings.showMonthsShort ? settings.monthsShort : settings.monthsFull ) +
                createYearLabel(),
                settings.klass.header
            ) + Pick._.node(
                'table',
                tableHead +
                Pick._.node(
                    'tbody',
                    Pick._.range({
                        min: 0,
                        max: WEEKS_IN_CALENDAR - 1,
                        item: function( rowCounter ) {

                            // If Monday is the first day and the month starts on Sunday, shift the date back a week.
                            var shiftDateBy = settings.firstDay && maker.create([ viewsetObject.year, viewsetObject.month, 1 ]).day === 0 ? -7 : 0

                            return Pick._.node( 'tr',
                                Pick._.range({
                                    min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index
                                    max: function() {
                                        return this.min + DAYS_IN_WEEK - 1
                                    },
                                    item: function( targetDate ) {

                                        // Convert the time date from a relative date to a target date.
                                        targetDate = maker.create([ viewsetObject.year, viewsetObject.month, targetDate + ( settings.firstDay ? 1 : 0 ) ])

                                        return Pick._.node( 'td',
                                            Pick._.node(
                                                'div',
                                                targetDate.date,
                                                (function( klasses ) {

                                                    // Add the `infocus` or `outfocus` classes based on month in view.
                                                    klasses.push( viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus )

                                                    // Add the `today` class if needed.
                                                    if ( nowObject.pick == targetDate.pick ) {
                                                        klasses.push( settings.klass.now )
                                                    }

                                                    // Add the `selected` class if something's selected and the time matches.
                                                    if ( selectedObject && selectedObject.pick == targetDate.pick ) {
                                                        klasses.push( settings.klass.selected )
                                                    }

                                                    // Add the `highlighted` class if something's highlighted and the time matches.
                                                    if ( highlightedObject && highlightedObject.pick == targetDate.pick ) {
                                                        klasses.push( settings.klass.highlighted )
                                                    }

                                                    // Add the `disabled` class if something's disabled and the object matches.
                                                    if ( disabledCollection && maker.disabled( targetDate ) || targetDate.pick < minLimitObject.pick || targetDate.pick > maxLimitObject.pick ) {
                                                        klasses.push( settings.klass.disabled )
                                                    }

                                                    return klasses.join( ' ' )
                                                })([ settings.klass.day ]),
                                                'data-pick=' + targetDate.pick
                                            )
                                        ) //endreturn
                                    }
                                })
                            ) //endreturn
                        }
                    })
                ),
                settings.klass.table
            ) +

            Pick._.node(
                'div',
                Pick._.node( 'button', settings.today, settings.klass.buttonToday, 'data-pick=' + nowObject.pick + ( isOpen ? '' : ' disabled' ) ) +
                Pick._.node( 'button', settings.clear, settings.klass.buttonClear, 'data-clear=1' + ( isOpen ? '' : ' disabled' ) ),
                settings.klass.footer
            ) //endreturn
        }, //content


        defaults: {

            // Months and weekdays
            monthsFull: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ],
            monthsShort: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ],
            weekdaysFull: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
            weekdaysShort: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ],

            // Today and clear
            today: 'Today',
            clear: 'Clear',

            // The format to show on the `input` element
            format: 'd mmmm, yyyy',

            // Classes
            klass: {

                table: 'picker__table',

                header: 'picker__header',

                navPrev: 'picker__nav--prev',
                navNext: 'picker__nav--next',
                navDisabled: 'picker__nav--disabled',

                month: 'picker__month',
                year: 'picker__year',

                selectMonth: 'picker__select--month',
                selectYear: 'picker__select--year',

                weekdays: 'picker__weekday',

                day: 'picker__day',
                disabled: 'picker__day--disabled',
                selected: 'picker__day--selected',
                highlighted: 'picker__day--highlighted',
                now: 'picker__day--today',
                infocus: 'picker__day--infocus',
                outfocus: 'picker__day--outfocus',

                footer: 'picker__footer',

                buttonClear: 'picker__button--clear',
                buttonToday: 'picker__button--today'
            }
        }
    })
    // $( '.input' ).pick( 'pickadate', {
    //     // something: true
    // })
</script>-->
